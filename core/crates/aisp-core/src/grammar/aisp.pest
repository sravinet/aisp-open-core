// AISP 5.1 Grammar Definition for Robust Parsing
// Security-hardened with error recovery and adversarial input resistance

WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* | ";;" ~ (!"\n" ~ ANY)* }
MATH_COMMENT = { ";;" ~ (!"\n" ~ ANY)* }

// Top-level document structure with error recovery
aisp_document = { 
    SOI ~ 
    header ~ 
    domain_protocol_decl? ~
    aisp_blocks ~ 
    EOI 
}

// Header with version, identifier, and date
header = { "ùî∏" ~ version ~ "." ~ identifier ~ "@" ~ date }
version = { ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
identifier = { (ASCII_ALPHANUMERIC | "-" | "_" | ".")+ }
date = { ASCII_DIGIT{4} ~ "-" ~ ASCII_DIGIT{2} ~ "-" ~ ASCII_DIGIT{2} }

// Domain and protocol declarations with Greek letters
domain_protocol_decl = { 
    (gamma_decl ~ rho_decl?) | 
    (rho_decl ~ gamma_decl?) 
}
gamma_decl = { "Œ≥" ~ "‚âî" ~ domain_path }
rho_decl = { "œÅ" ~ "‚âî" ~ "‚ü®" ~ tag_list ~ "‚ü©" }
domain_path = { (ASCII_ALPHANUMERIC | "." | "-" | "_")+ }
tag_list = { tag ~ ("," ~ tag)* }
tag = { (ASCII_ALPHANUMERIC | "-" | "_")+ }

// AISP block structure with error recovery
aisp_blocks = { aisp_block* }
aisp_block = { 
    omega_block | 
    sigma_block | 
    gamma_block | 
    lambda_block | 
    chi_block | 
    epsilon_block |
    malformed_block  // Error recovery
}

// Œ© (Omega) - Meta block
omega_block = { 
    "‚ü¶" ~ "Œ©" ~ ":" ~ "Meta" ~ "‚üß" ~ "{" ~ 
    meta_entries ~ 
    "}" 
}
meta_entries = { meta_entry* }
meta_entry = { 
    (forall_constraint | meta_assignment) ~ ";"?
}
forall_constraint = { 
    "‚àÄ" ~ variable ~ "‚àà" ~ type_expr ~ ":" ~ logical_expr 
}
meta_assignment = { 
    identifier ~ "‚âú" ~ string_literal 
}

// Œ£ (Sigma) - Types block  
sigma_block = { 
    "‚ü¶" ~ "Œ£" ~ ":" ~ "Types" ~ "‚üß" ~ "{" ~ 
    type_definitions ~ 
    "}" 
}
type_definitions = { type_definition* }
type_definition = { 
    identifier ~ "‚âú" ~ type_expression ~ ";"?
}

// Type expressions with mathematical notation
type_expression = { 
    union_type | 
    intersection_type |
    function_type |
    set_type |
    tuple_type |
    constrained_type |
    basic_type |
    vector_type
}

union_type = { type_term ~ ("|" ~ type_term)+ }
intersection_type = { type_term ~ ("‚à©" ~ type_term)+ }
function_type = { type_term ~ "‚Üí" ~ type_term }
set_type = { "{" ~ type_term ~ ("|" ~ constraint)? ~ "}" }
tuple_type = { "‚ü®" ~ type_field_list ~ "‚ü©" }
constrained_type = { type_term ~ constraint }
vector_type = { type_term ~ ("‚äï" ~ type_term)+ }

type_field_list = { type_field ~ ("," ~ type_field)* }
type_field = { identifier ~ ":" ~ type_expression }
type_term = { 
    "(" ~ type_expression ~ ")" |
    basic_type |
    identifier |
    unicode_type_symbol
}

// Mathematical type symbols
basic_type = { 
    "‚Ñï" | "‚Ñù" | "‚ÑÇ" | "‚Ñö" | "‚Ñ§" |  // Number types
    "ùïä" |                          // String type  
    "ùîπ" |                          // Boolean type
    "Any"                          // Any type
}

unicode_type_symbol = { 
    "‚Ñù" ~ ASCII_DIGIT+ ~ (":" ~ identifier)? |
    "‚Ñï" ~ ASCII_DIGIT+ |
    "ùîπ" ~ ASCII_DIGIT+
}

// Œì (Gamma) - Rules block
gamma_block = { 
    "‚ü¶" ~ "Œì" ~ ":" ~ "Rules" ~ "‚üß" ~ "{" ~ 
    rule_definitions ~ 
    "}" 
}
rule_definitions = { rule_definition* }
rule_definition = { 
    (MATH_COMMENT | logical_rule | constraint_rule) ~ ";"?
}

logical_rule = { 
    quantified_expr |
    logical_expr
}

quantified_expr = { 
    quantifier ~ variable ~ (":" ~ type_expr)? ~ ":" ~ logical_expr
}
quantifier = { "‚àÄ" | "‚àÉ" }

// Œõ (Lambda) - Functions block
lambda_block = { 
    "‚ü¶" ~ "Œõ" ~ ":" ~ ("Funcs" | "Functions") ~ "‚üß" ~ "{" ~ 
    function_definitions ~ 
    "}" 
}
function_definitions = { function_definition* }
function_definition = { 
    (MATH_COMMENT | (identifier ~ "‚âú" ~ lambda_expression)) ~ ";"?
}

lambda_expression = { 
    "Œª" ~ parameter_list ~ "." ~ function_body |
    function_body
}
parameter_list = { 
    parameter ~ ("," ~ parameter)* |
    parameter
}
parameter = { 
    identifier ~ (":" ~ type_expression)? 
}

function_body = { 
    conditional_expr |
    pattern_match_expr |
    mathematical_expr |
    identifier |
    literal
}

conditional_expr = { 
    "if" ~ logical_expr ~ "then" ~ function_body ~ "else" ~ function_body |
    logical_expr ~ "‚Üí" ~ function_body ~ ("|" ~ logical_expr ~ "‚Üí" ~ function_body)*
}

pattern_match_expr = { 
    "(" ~ pattern_case ~ ("|" ~ pattern_case)* ~ ")"
}
pattern_case = { 
    pattern ~ "‚Üí" ~ function_body 
}

// Œß (Chi) - Errors block
chi_block = { 
    "‚ü¶" ~ "Œß" ~ ":" ~ "Errors" ~ "‚üß" ~ "{" ~ 
    error_definitions ~ 
    "}" 
}
error_definitions = { error_definition* }
error_definition = { 
    identifier ~ "‚âú" ~ error_condition ~ ";"?
}
error_condition = { 
    logical_expr |
    comparison_expr
}

// Œï (Epsilon) - Evidence block
epsilon_block = { 
    "‚ü¶" ~ "Œï" ~ (":" ~ "Evidence")? ~ "‚üß" ~ "‚ü®" ~ 
    evidence_entries ~ 
    "‚ü©" 
}
evidence_entries = { evidence_entry* }
evidence_entry = { 
    evidence_assignment |
    evidence_proof
}
evidence_assignment = { 
    evidence_symbol ~ "‚âú" ~ evidence_value ~ ";"?
}
evidence_proof = { 
    "‚ä¢" ~ proof_claim ~ (":" ~ proof_details)? ~ ";"?
}

evidence_symbol = { 
    "Œ¥" | "|ùîÖ|" | "œÜ" | "œÑ" | identifier
}
evidence_value = { 
    number |
    fraction |
    quality_tier |
    string_literal
}

quality_tier = { 
    "‚óä" ~ "‚Å∫"* |
    "‚óä" ~ "‚Åª"*
}

// Mathematical and logical expressions
mathematical_expr = { 
    comparison_expr
}

comparison_expr = { 
    additive_expr ~ (comparison_op ~ additive_expr)*
}
comparison_op = { 
    "‚â§" | "‚â•" | "<" | ">" | "‚â°" | "‚â†" | "=" | "‚âà" |
    "‚àà" | "‚àâ" | "‚äÜ" | "‚äá" | "‚à©" | "‚à™"
}

additive_expr = { 
    multiplicative_expr ~ (("+" | "-" | "‚äï" | "‚äó") ~ multiplicative_expr)*
}
multiplicative_expr = { 
    power_expr ~ (("*" | "/" | "√ó" | "√∑") ~ power_expr)*
}
power_expr = { 
    unary_expr ~ ("^" ~ unary_expr)*
}
unary_expr = { 
    ("¬¨" | "-" | "+")* ~ primary_expr
}

primary_expr = { 
    "(" ~ mathematical_expr ~ ")" |
    function_call |
    set_expr |
    abs_expr |
    number |
    identifier |
    unicode_symbol
}

function_call = { 
    identifier ~ "(" ~ argument_list? ~ ")"
}
argument_list = { 
    mathematical_expr ~ ("," ~ mathematical_expr)*
}

set_expr = { 
    "{" ~ set_element_list? ~ "}" |
    "[" ~ range_expr ~ "]"
}
set_element_list = { 
    mathematical_expr ~ ("," ~ mathematical_expr)*
}
range_expr = { 
    mathematical_expr ~ "," ~ mathematical_expr
}

abs_expr = { 
    "|" ~ mathematical_expr ~ "|"
}

// Logical expressions
logical_expr = { 
    implication_expr
}
implication_expr = { 
    disjunction_expr ~ ("‚Üí" ~ disjunction_expr)*
}
disjunction_expr = { 
    conjunction_expr ~ ("‚à®" ~ conjunction_expr)*
}
conjunction_expr = { 
    negation_expr ~ ("‚àß" ~ negation_expr)*
}
negation_expr = { 
    "¬¨"* ~ logical_primary
}
logical_primary = { 
    "(" ~ logical_expr ~ ")" |
    comparison_expr |
    "‚ä§" | "‚ä•" |
    identifier
}

// Constraints and patterns
constraint = { 
    logical_expr
}
pattern = { 
    identifier |
    literal |
    "(" ~ pattern ~ ")"
}

// Unicode mathematical symbols
unicode_symbol = { 
    "‚àÄ" | "‚àÉ" | "‚àà" | "‚àâ" | "‚à©" | "‚à™" | "‚äÜ" | "‚äá" | 
    "‚â°" | "‚â†" | "‚â§" | "‚â•" | "‚âà" |
    "‚Üí" | "‚Üê" | "‚Üî" | "‚äï" | "‚äó" | "‚äò" |
    "Œª" | "Œ¥" | "œÜ" | "Œµ" | "œÄ" | "œÅ" | "œÑ" | "Œ≥" |
    "‚Ñï" | "‚Ñù" | "‚ÑÇ" | "‚Ñö" | "‚Ñ§" | "ùïä" | "ùîπ" |
    "‚óä" | "‚ä§" | "‚ä•" | "‚àû"
}

// Primitives
variable = { identifier }
type_expr = { type_expression }
constraint_rule = { logical_expr }
proof_claim = { identifier ~ (":" ~ identifier)* }
proof_details = { identifier ~ ("-" ~ identifier)* }

identifier = { 
    (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_" | "-")* 
}

number = { 
    special_number |
    ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? ~ (("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT+)?
}

special_number = {
    "‚àû" | "NaN" | "‚ä•" | "undefined"
}

fraction = { 
    ASCII_DIGIT+ ~ "/" ~ ASCII_DIGIT+
}

string_literal = { 
    "\"" ~ (!"\"" ~ ANY)* ~ "\""
}

literal = { 
    number |
    string_literal |
    "true" | "false" |
    unicode_symbol
}

// Error recovery for malformed blocks
malformed_block = { 
    "‚ü¶" ~ (!"‚üß" ~ ANY)* ~ ("‚üß" | &EOI)
}